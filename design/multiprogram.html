<!DOCTYPE html>
<html lang="ja" data-bs-theme="auto">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="プレハブ小屋">
        <link rel="canonical" href="https://github.com/showa-yojyo/taoup/design/multiprogram.html">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Multiprogramming - The Art of Unix Programming 読書ノート</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" disabled>
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../css/style.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../index.html">The Art of Unix Programming 読書ノート</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../index.html" class="nav-link">Home</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Notes</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../preface.html" class="dropdown-item">Preface</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Context</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../context/philosophy.html" class="dropdown-item">Philosophy</a>
</li>
            
<li>
    <a href="../context/history.html" class="dropdown-item">History</a>
</li>
            
<li>
    <a href="../context/contrasts.html" class="dropdown-item">Contrasts</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Design</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="modularity.html" class="dropdown-item">Modularity</a>
</li>
            
<li>
    <a href="textuality.html" class="dropdown-item">Textuality</a>
</li>
            
<li>
    <a href="transparency.html" class="dropdown-item">Transparency</a>
</li>
            
<li>
    <a href="multiprogram.html" class="dropdown-item active" aria-current="page">Multiprogramming</a>
</li>
            
<li>
    <a href="minilanguages.html" class="dropdown-item">Minilanguages</a>
</li>
            
<li>
    <a href="generation.html" class="dropdown-item">Generation</a>
</li>
            
<li>
    <a href="configuration.html" class="dropdown-item">Configuration</a>
</li>
            
<li>
    <a href="interface.html" class="dropdown-item">Interfaces</a>
</li>
            
<li>
    <a href="optimization.html" class="dropdown-item">Optimization</a>
</li>
            
<li>
    <a href="complexity.html" class="dropdown-item">Complexity</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Implementation</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../implementation/languages.html" class="dropdown-item">Languages</a>
</li>
            
<li>
    <a href="../implementation/tools.html" class="dropdown-item">Tools</a>
</li>
            
<li>
    <a href="../implementation/reuse.html" class="dropdown-item">Reuse</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Community</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../community/portability.html" class="dropdown-item">Portability</a>
</li>
            
<li>
    <a href="../community/documentation.html" class="dropdown-item">Documentation</a>
</li>
            
<li>
    <a href="../community/opensource.html" class="dropdown-item">Open Source</a>
</li>
            
<li>
    <a href="../community/futures.html" class="dropdown-item">Futures</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/showa-yojyo/taoup/issues" class="nav-link">Issues</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="transparency.html" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="minilanguages.html" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/showa-yojyo/taoup/edit/main/docs/design/multiprogram.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                            <li class="nav-item dropdown">
                              <button id="theme-menu" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme" class="nav-link dropdown-toggle">
                                <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                <span class="d-lg-none ms-2">Toggle theme</span>
                              </button>
                              <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                                    <i class="fa-solid fa-sun fa-fw"></i>
                                    <span class="ms-2">Light</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                                    <i class="fa-solid fa-moon fa-fw"></i>
                                    <span class="ms-2">Dark</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="auto" aria-pressed="true">
                                    <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                    <span class="ms-2">Auto</span>
                                    <i class="fa-solid fa-check ms-auto"></i>
                                  </button>
                                </li>
                              </ul>
                            </li>
                    </ul>
                </div>
            </div>
        </div>
        <script src="../js/darkmode.js"></script>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="2"><a href="#separating-complexity-control-from-performance-tuning" class="nav-link">Separating Complexity Control from Performance Tuning</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#taxonomy-of-unix-ipc-methods" class="nav-link">Taxonomy of Unix IPC Methods</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#handing-off-tasks-to-specialist-programs" class="nav-link">Handing off Tasks to Specialist Programs</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#pipes-redirection-and-filters" class="nav-link">Pipes, Redirection, and Filters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#wrappers" class="nav-link">Wrappers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#security-wrappers-and-bernstein-chaining" class="nav-link">Security Wrappers and Bernstein Chaining</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#slave-processes" class="nav-link">Slave Processes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#peer-to-peer-inter-process-communication" class="nav-link">Peer-to-Peer Inter-Process Communication</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#problems-and-methods-to-avoid" class="nav-link">Problems and Methods to Avoid</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#obsolescent-unix-ipc-methods" class="nav-link">Obsolescent Unix IPC Methods</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#remote-procedure-calls" class="nav-link">Remote Procedure Calls</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#threads-threat-or-menace" class="nav-link">Threads — Threat or Menace?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="2"><a href="#process-partitioning-at-the-design-level" class="nav-link">Process Partitioning at the Design Level</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="chapter-7-multiprogramming">Chapter 7. Multiprogramming<a class="headerlink" href="#chapter-7-multiprogramming" title="Permanent link">&para;</a></h1>
<div class="toc"><span class="toctitle">見出し一覧</span><ul>
<li><a href="#separating-complexity-control-from-performance-tuning">Separating Complexity Control from Performance Tuning</a></li>
<li><a href="#taxonomy-of-unix-ipc-methods">Taxonomy of Unix IPC Methods</a><ul>
<li><a href="#handing-off-tasks-to-specialist-programs">Handing off Tasks to Specialist Programs</a><ul>
<li><a href="#case-study-the-mutt-mail-user-agent">Case Study: The mutt Mail User Agent</a></li>
</ul>
</li>
<li><a href="#pipes-redirection-and-filters">Pipes, Redirection, and Filters</a><ul>
<li><a href="#case-study-piping-to-a-pager">Case Study: Piping to a Pager</a></li>
<li><a href="#case-study-making-word-lists">Case Study: Making Word Lists</a></li>
<li><a href="#case-study-pic2graph">Case Study: pic2graph</a></li>
<li><a href="#case-study-bc1-and-dc1">Case Study: bc(1) and dc(1)</a></li>
<li><a href="#anti-case-study-why-isnt-fetchmail-a-pipeline">Anti-Case Study: Why Isn't fetchmail a Pipeline?</a></li>
</ul>
</li>
<li><a href="#wrappers">Wrappers</a><ul>
<li><a href="#case-study-backup-scripts">Case Study: Backup Scripts</a></li>
</ul>
</li>
<li><a href="#security-wrappers-and-bernstein-chaining">Security Wrappers and Bernstein Chaining</a></li>
<li><a href="#slave-processes">Slave Processes</a><ul>
<li><a href="#case-study-scp-and-ssh">Case Study: scp and ssh</a></li>
</ul>
</li>
<li><a href="#peer-to-peer-inter-process-communication">Peer-to-Peer Inter-Process Communication</a><ul>
<li><a href="#tempfiles">Tempfiles</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#system-daemons-and-conventional-signals">System Daemons and Conventional Signals</a></li>
<li><a href="#case-study-fetchmails-use-of-signals">Case Study: fetchmail's Use of Signals</a></li>
<li><a href="#sockets">Sockets</a><ul>
<li><a href="#case-study-postgresql">Case Study: PostgreSQL</a></li>
<li><a href="#case-study-freeciv">Case Study: Freeciv</a></li>
</ul>
</li>
<li><a href="#shared-memory">Shared Memory</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#problems-and-methods-to-avoid">Problems and Methods to Avoid</a><ul>
<li><a href="#obsolescent-unix-ipc-methods">Obsolescent Unix IPC Methods</a><ul>
<li><a href="#system-v-ipc">System V IPC</a></li>
<li><a href="#streams">Streams</a></li>
</ul>
</li>
<li><a href="#remote-procedure-calls">Remote Procedure Calls</a></li>
<li><a href="#threads-threat-or-menace">Threads — Threat or Menace?</a></li>
</ul>
</li>
<li><a href="#process-partitioning-at-the-design-level">Process Partitioning at the Design Level</a></li>
</ul>
</div>
<blockquote>
<p>The most characteristic program-modularization technique of Unix is splitting
large programs into multiple cooperating processes.</p>
</blockquote>
<p>ここでは cooperating に重点が置かれていると考える。</p>
<p>Unix はプログラムをより単純なサブプロセスに分割し、これらの間のインターフェイスに集中することを奨励している。基本的な方法には次の三つがある：</p>
<ul>
<li>プロセス起動を安上がりなものにする</li>
<li>プロセスが比較的かんたんに通信できるようにする方法（リダイレクト、パイプ、
  等々）を与える</li>
<li>パイプやソケットを通して渡せる、単純で透過的なテキストデータ形式の使用を奨励す
  る</li>
</ul>
<p>安価なプロセス起動と容易なプロセス制御は Unix 式のプログラミングを可能にする重要な要素だ。</p>
<p>シェルでは、パイプで接続された複数のプロセス団をバックグラウンド、フォアグラウンド、その混合のどれであっても走らせることは比較的容易に設定可能だ。</p>
<p>プログラムを協調プロセスに分割することの利点と欠点：</p>
<ul>
<li>大域的な複雑さを軽減する</li>
<li>プロセス間の情報やコマンドの受け渡しに使われる通信規約の設計が難しい</li>
</ul>
<blockquote>
<p>In software systems of all kinds, bugs collect at interfaces.</p>
</blockquote>
<p>本当の課題は通信規格の構文ではなく論理、つまり、十分に表現力があり、膠着状態にならない規格を設計することだ。</p>
<h2 id="separating-complexity-control-from-performance-tuning">Separating Complexity Control from Performance Tuning<a class="headerlink" href="#separating-complexity-control-from-performance-tuning" title="Permanent link">&para;</a></h2>
<blockquote>
<p>First, though, we need to dispose of a few red herrings.</p>
</blockquote>
<p>英語では、だいじなことから目を逸らさせる人や物をアカニシンと表現することがある。</p>
<!-- red herring: a fact, idea, or subject that takes people's attention away from the central point being considered -->

<blockquote>
<p>Our discussion is <em>not</em> going to be about using concurrency to improve
performance.</p>
</blockquote>
<p>関連性の高いアカニシンの一つはスレッドだという。</p>
<p>スレッドは大域的な複雑さを軽減するのではなく、むしろ増大させる。切実な必要性がある場合を除き、避けろ。</p>
<p>プログラムを協働プロセスに分割するもう一つの重要な理由は、より良い安全保障のためだ：</p>
<ul>
<li>プログラムを setuid を必要とするプロセスとそれ以外の大きなプロセスに分割する。</li>
<li>前者は特権プロセスで、これだけが安全保障上重要なシステム資源へのアクセスが可能
  だ。</li>
<li>両プロセスを協働する。</li>
</ul>
<p>脚注に setuid に関する補足がある：</p>
<blockquote>
<p>A setuid program runs not with the privileges of the user calling it, but with
the privileges of the owner of the executable. This feature can be used to
give restricted, program-controlled access to things like the password file
that nonadministrators should not be allowed to modify directly.</p>
</blockquote>
<p>少し調べたら <code>passwd</code> の例が出てきて、これなら setuid の概念を理解しやすいと思った。次のようなものだ：この実行形式を一般使用者が実行するとその所有者である root
の権限でプロセスが走る。その結果、一般使用者であっても所有者が root であるファイル <code>/etc/shadow</code> を変更することが可能となる。</p>
<h2 id="taxonomy-of-unix-ipc-methods">Taxonomy of Unix IPC Methods<a class="headerlink" href="#taxonomy-of-unix-ipc-methods" title="Permanent link">&para;</a></h2>
<p>最も単純な構成が最も良い。</p>
<h3 id="handing-off-tasks-to-specialist-programs">Handing off Tasks to Specialist Programs<a class="headerlink" href="#handing-off-tasks-to-specialist-programs" title="Permanent link">&para;</a></h3>
<p>術語 shell out を定義する一文：</p>
<blockquote>
<p>In the simplest form of interprogram cooperation enabled by inexpensive
process spawning, a program runs another to accomplish a specialized task.
Because the called program is often specified as a Unix shell command through
the system(3) call, this is often called <em>shelling out</em> to the called program.</p>
</blockquote>
<p>協調の流れ：</p>
<ol>
<li>呼び出されたプログラムは、キーボードと画面を継承し、完了まで実行される。</li>
<li>終了すると、呼び出し元プログラムがキーボードと画面の制御を取り戻し、実行を再
   開する。</li>
</ol>
<p>この型のプログラム間の通信がない協調において、交信規格設計は問題ではない。</p>
<p>Unix の典型的な shell out はテキストエディター呼び出しだ：</p>
<blockquote>
<p>In the Unix tradition one does <em>not</em> bundle purpose-built editors into programs
that require general text-edited input. Instead, one allows the user to
specify an editor of his or her choice to be called when editing needs to be
done.</p>
</blockquote>
<p>このために環境変数 <code>EDITOR</code> や <code>VISUAL</code> を呼び出し元プログラムとは独立して指定可能なのだ。プログラムによっては固有の環境変数 (e.g. <code>GIT_EDITOR</code>) が存在することもある。</p>
<blockquote>
<p>The specialist program usually communicates with its parent through the file
system, by reading or modifying file(s) with specified location(s); this is
how editor or mailer shellouts work.</p>
</blockquote>
<p>エディターに当たるほうが専門プログラムだ。</p>
<blockquote>
<p>They key point about all these cases is that the specialist programs don't
handshake with the parent while they are running.</p>
</blockquote>
<p>この文脈で言う handshake は交信確立とか応答確認などの意味に取れ。</p>
<h4 id="case-study-the-mutt-mail-user-agent">Case Study: The <code>mutt</code> Mail User Agent<a class="headerlink" href="#case-study-the-mutt-mail-user-agent" title="Permanent link">&para;</a></h4>
<p><a href="http://www.mutt.org/">Mutt</a> は簡単な画面指向のインターフェイスを備えたメールクライアントだ。単一キーストロークのコマンドでメールを閲覧したり読んだりできる。</p>
<p>Mutt をメール作成で使う場合、使用者はコマンドライン引数としてアドレスを指定して呼び出すか、返信コマンドの一つを使って呼び出す。このとき、Mutt は環境変数
<code>EDITOR</code> を参照する。メール本文執筆用に一時ファイル名を生成し、<code>EDITOR</code> の値を一時ファイル名を引数として呼び出す。</p>
<blockquote>
<p>Almost all Unix mail- and netnews-composition programs observe the same
convention.</p>
</blockquote>
<p>要点はここから：</p>
<blockquote>
<p>An important variant of this strategy shells out to a small proxy program that
passes the specialist job to an already-running instance of a big program,
like an editor or a Web browser.</p>
</blockquote>
<p>「すでに動作中の」というのがキモで、変数 <code>EDITOR</code> が指すプログラムが巨大で起動が重いようなものでも、動作中のプロセスそのものがポップアップして、一時ファイルがそこに閲覧・編集可能な状態で現れることが使用者に期待される（そういう動作を促すような代行プログラムを shell out する）。</p>
<p>また、本書では <code>EDITOR=emacsclient</code> だが、WSL 環境で Windows 側の Visual Studio
Code を使う場合にも同じ議論が適用される。設定は <code>EDITOR=code</code> だ。</p>
<h3 id="pipes-redirection-and-filters">Pipes, Redirection, and Filters<a class="headerlink" href="#pipes-redirection-and-filters" title="Permanent link">&para;</a></h3>
<p>Unix パイプの発明者は Doug McIlroy という人物だ：</p>
<blockquote>
<p>After Ken Thompson and Dennis Ritchie, the single most important formative
figure of early Unix was probably Doug McIlroy. His invention of the <em>pipe</em>
construct reverberated through the design of Unix, encouraging its nascent
do-one-thing-well philosophy and inspiring most of the later forms of IPC in
the Unix design (in particular, the socket abstraction used for networking).</p>
</blockquote>
<p>パイプはどのプログラムも最初から標準入力と標準出力を利用できるという慣例に依存している。</p>
<blockquote>
<p>Many programs can be written as <em>filters</em>, which read sequentially from
standard input and write only to standard output.</p>
</blockquote>
<p>パイプ操作は、あるプログラムの標準出力を別のプログラムの標準入力に接続する。このように接続されたプログラムの連鎖をパイプラインと呼ぶ。例えば</p>
<pre><code class="language-console">ls | wc
</code></pre>
<p>と書くと、現在のディレクトリ一覧の文字数、単語数、行数が表示される。</p>
<p>McIlroy 本人が気に入っているパイプラインの一つは <code>bc | speak</code> であるという。ゆっくりボイスに数字を読み上げさせるようなものだろう。</p>
<blockquote>
<p>It's important to note that all the stages in a pipeline run concurrently.</p>
</blockquote>
<p>この性質があるので先のパイプラインは <code>ls &gt; foo; wc &lt; foo</code> よりも効率が良い。</p>
<p>パイプの大きな弱点は一方通行であることだ。 パイプライン成分はパイプを停止する以外の方法で制御情報をパイプに戻すことはできない。</p>
<h4 id="case-study-piping-to-a-pager">Case Study: Piping to a Pager<a class="headerlink" href="#case-study-piping-to-a-pager" title="Permanent link">&para;</a></h4>
<p>全部見るにはスクロールが必要であるほど出力が縦方向に長くなりがちな <code>ps</code> と、標準入力を画面縦寸法に分割して表示する <code>more</code> を組み合わせる。</p>
<pre><code class="language-console">ps | more
</code></pre>
<p>このようにタイプして ps(1) の出力を more(1) の入力に渡すと、それぞれのキーストロークの後に、プロセス一覧のページサイズの断片が順番に表示される。</p>
<blockquote>
<p>The ability to combine programs like this can be extremely useful. But the
real win here is not cute combinations; it's that because both pipes and
more(1) exist, <em>other programs can be simpler</em>.</p>
</blockquote>
<ul>
<li>ps(1), ls(1), ... がそれぞれ個別にページャーを実装する必要がない。</li>
<li>ページャーをカスタマイズしたい場合は <code>more</code> の部分だけをカスタマイズすればいい。</li>
</ul>
<p>実際、現代では more(1) ではなく less(1) を利用するのが普通だ。後者は上にもスクロール可能だ。</p>
<h4 id="case-study-making-word-lists">Case Study: Making Word Lists<a class="headerlink" href="#case-study-making-word-lists" title="Permanent link">&para;</a></h4>
<p>これは実際に実行してみるといい：</p>
<pre><code class="language-console">tr -c '[:alnum:]' '[\n*]' | sort -iu | grep -v '^[0-9]*$'
</code></pre>
<p>標準入力には、本書の適当なパラグラフをコピー＆ペースト。するとこのパイプラインは：</p>
<blockquote>
<p>Together, these generate a sorted wordlist to standard output from text on
standard input.</p>
</blockquote>
<h4 id="case-study-pic2graph">Case Study: <code>pic2graph</code><a class="headerlink" href="#case-study-pic2graph" title="Permanent link">&para;</a></h4>
<p>シェルスクリプトの一部が抜粋されているが、パイプは一箇所しかない。サブシェルの結果をパイプで <code>groff</code> に流すという構造だ。</p>
<blockquote>
<p>All these details are hidden from the user, who simply sees PIC source go in
one end and a bitmap ready for inclusion in a Web page come out the other.</p>
</blockquote>
<p>次の観点によりこの例を示したとある：</p>
<blockquote>
<p>This is an interesting example because it illustrates how pipes and filtering
can adapt programs to unexpected uses. The program that interprets PIC,
pic(1), was originally designed only to be used for embedding diagrams in
typeset documents.</p>
</blockquote>
<h4 id="case-study-bc1-and-dc1">Case Study: bc(1) and dc(1)<a class="headerlink" href="#case-study-bc1-and-dc1" title="Permanent link">&para;</a></h4>
<p>これを読むまで勘違いしていたが、逆ポーランド記法は（逆だから）オペランドを先に書く。演算子を後ろに書く。</p>
<ul>
<li>dc(1) プログラムは逆ポーランド記法 (RPN) からなるテキスト行を標準入力で受け取
  り、計算された答えを標準出力に出力する。</li>
<li>bc(1) プログラムは従来の代数記法に似た、より精巧な中置構文を受け付ける。</li>
</ul>
<p>古いバージョンの bc(1) は自身では計算を行わず、パイプ経由で dc(1) にコマンドを渡していた。次のように役割を分担していた：</p>
<ul>
<li>bc(1) は変数の代入と関数の展開を行い、中置記法を逆ポーランド記法に変換する。</li>
<li>dc(1) は RPN 変換された入力式を受け取って評価する。</li>
</ul>
<p>このように機能を分離しておくことには利点がある：</p>
<blockquote>
<p>It means that users get to choose their preferred notation, but the logic for
arbitrary-precision numeric calculation (which is moderately tricky) does not
have to be duplicated. Each of the pair of programs can be less complex than
one calculator with a choice of notations would be. The two components can be
debugged and mentally modeled independently of each other.</p>
</blockquote>
<h4 id="anti-case-study-why-isnt-fetchmail-a-pipeline">Anti-Case Study: Why Isn't fetchmail a Pipeline?<a class="headerlink" href="#anti-case-study-why-isnt-fetchmail-a-pipeline" title="Permanent link">&para;</a></h4>
<p>パイプラインの単方向性とメールクライアントは相性が悪い。</p>
<blockquote>
<p>One of the things the fetcher program (<code>imap</code> or <code>pop</code>) would have to do is
decide whether to send a delete request for each message it fetches.</p>
</blockquote>
<p>現在の <code>fetchmail</code> の編成ではローカルの SMTP リスナーがメッセージの責任を引き受けたことがわかるまで、POP/IMAP サーバーへの要求送信を遅らせることができる。本書の小さい部品＋パイプライン編成ではその特性を失うことになる。</p>
<h3 id="wrappers">Wrappers<a class="headerlink" href="#wrappers" title="Permanent link">&para;</a></h3>
<p>ラッパーは呼び出されたプログラムに対して新しいインターフェイスを作成したり、それを特殊化したりするものだ。専門化といったほうがいいか？</p>
<ul>
<li>ラッパーは多くの場合、シェルパイプラインの詳細を隠すために使われる。</li>
<li>実行中に二つのプログラムが通信することはないため、関連する通信規約は存在しない。</li>
<li>呼び出されるプログラムの動作を変更する引数を備えるものがある。</li>
</ul>
<h4 id="case-study-backup-scripts">Case Study: Backup Scripts<a class="headerlink" href="#case-study-backup-scripts" title="Permanent link">&para;</a></h4>
<p>ワンライナーであってもラッパーはラッパーだ：</p>
<pre><code class="language-bash">tar -czvf /dev/st0 &quot;$@&quot;
</code></pre>
<blockquote>
<p>This is a wrapper for the tar(1) tape archiver utility which simply supplies
one fixed argument (the tape device <code>/dev/st0</code>) and passes to tar all the other
arguments supplied by the user (“<code>$@</code>”).</p>
</blockquote>
<p>まさに上の内容とよく似た、ストレージの内容を rsync(1) で別のストレージにバックアップするスクリプトを用意することが普通にある。</p>
<h3 id="security-wrappers-and-bernstein-chaining">Security Wrappers and Bernstein Chaining<a class="headerlink" href="#security-wrappers-and-bernstein-chaining" title="Permanent link">&para;</a></h3>
<p>ラッパースクリプトの一般的な使い方の一つに安全保障ラッパーがある。安全保障スクリプトはある種の証明書を検査する守衛プログラムを呼び出し、守衛が返す値に基づいて条件付きで別のプログラムを実行することができる。</p>
<blockquote>
<p>Bernstein chaining is a specialized security-wrapper technique first invented
by Daniel J. Bernstein, who has employed it in a number of his packages.</p>
</blockquote>
<p>この人物は暗号学教授でもある。</p>
<p>Bernstein 連鎖はパイプラインのようなものであり、連続する各段階がそれと同時に実行されるのではなく、直前の段階を置き換えるものだ。</p>
<!-- to confine: to limit an activity, person, or problem in some way -->

<p>通常の応用例としては、保安特権を有するアプリケーションをある種の守衛プログラムに閉じこめ、その守衛プログラムからより特権の低いアプリケーションに状態を渡すことができる。この技法を <code>exec</code>/<code>fork</code> で組み合わせて、複数のプログラムを貼り合わせる。</p>
<blockquote>
<p>Each program performs some function and (if successful) runs exec(2) on the
rest of its command line.</p>
</blockquote>
<p>次のような実例がある。説明文がチンプンカンプンで理解できなかった：</p>
<ul>
<li>rblsmtpd パッケージ</li>
<li>qmail パッケージ</li>
<li>qmail-popup プログラム</li>
</ul>
<p>Bernstein 連鎖はアプリケーションの初期段階で特権を要し、それが不要となる後続処理で特権を外したいときに便利だ。</p>
<p>この技法の良い性質：</p>
<ul>
<li><code>exec</code> の後、子プログラムは真の使用者 ID を root に戻すことはできない。</li>
<li>連鎖に別のプログラムを挿入することでシステムの動作を変更できるので、単一プロセ
  スよりも柔軟性がある。</li>
</ul>
<h3 id="slave-processes">Slave Processes<a class="headerlink" href="#slave-processes" title="Permanent link">&para;</a></h3>
<p>時折、子プログラムは、標準入出力に接続されたパイプを通じて、呼び出し元からデータを受け取り、呼び出し元にデータを返すという対話的な処理を行うことがある。この方式では上述したどのパターンとも異なり、次の条件がある：</p>
<blockquote>
<p>both master and slave processes need to have internal state machines to handle
a protocol between them without deadlocking or racing.</p>
</blockquote>
<p>主プロセスは呼び出し元が自分のスレーブコマンドを設定できるようなコマンドラインスイッチや環境変数を支援するのが良い習慣だ：</p>
<blockquote>
<p>Among other things, this is useful for debugging; you will often find it handy
during development to invoke the real slave process from within a harness that
monitors and logs transactions between slave and master.</p>
</blockquote>
<p>自作プログラムにおいて主従プロセスの相互作用が怪しくなってきたと感じたら、ソケットや共有メモリーのような技法を使って、peer-to-peer 編成への移行を考える潮時であることがある。</p>
<h4 id="case-study-scp-and-ssh">Case Study: <code>scp</code> and <code>ssh</code><a class="headerlink" href="#case-study-scp-and-ssh" title="Permanent link">&para;</a></h4>
<p>scp(1) コマンドは ssh(1) を従プロセスとして呼び出し、<code>ssh</code> の標準出力から、プログレスバーのアスキーアニメーションとして報告を再整形するのに十分な情報を傍受する。</p>
<h3 id="peer-to-peer-inter-process-communication">Peer-to-Peer Inter-Process Communication<a class="headerlink" href="#peer-to-peer-inter-process-communication" title="Permanent link">&para;</a></h3>
<p>通信やネットワーキングでは通常、双方向にデータが自由に流れる peer-to-peer の情報経路が頻繁に必要となる。</p>
<h4 id="tempfiles">Tempfiles<a class="headerlink" href="#tempfiles" title="Permanent link">&para;</a></h4>
<p>協調プログラム間で一時ファイルを用いて情報を交換するプロセス間通信技法手法は最も古い。欠点はあるが、シェルスクリプトや、より精巧で協調的な通信方法が過剰な一回限りのプログラムでは、今でも有用な手法だ。</p>
<p>この技法の問題点：</p>
<ul>
<li>一時ファイルを削除する前に処理が中断された場合、ゴミが放置されがちだ。</li>
<li>一時ファイルに同じ名前を使った複数のプログラムのプロセス間で衝突が起こる。</li>
<li>一時ファイルを書き込む場所を攻撃者が知っている場合に、下記の問題が生じる。</li>
</ul>
<p>問題点その二は程度の低いプログラマーがやりがちだ。現代なら対処法がさらにいろいろある。</p>
<p>問題点その三：</p>
<blockquote>
<p>it can overwrite on that name and possibly either read the producer's data or
spoof the consumer process by inserting modified or spurious data into the
file. This is a security risk. If the processes involved have root privileges,
this is a very serious risk.</p>
</blockquote>
<!-- to spoof: to pretend to be someone -->
<!-- spurious: based on false reasoning or information that is not true -->

<p>先述のエディターの事例は一時ファイルのそれでもある。</p>
<h4 id="signals">Signals<a class="headerlink" href="#signals" title="Permanent link">&para;</a></h4>
<p>信号はプロセス間通信機能として設計されたものではない。OS が特定のエラーや緊要のイベントをプログラムに通知する方法として設計されたものだ。例：</p>
<ul>
<li><code>SIGHUP</code> 信号は、ある端末セッションが終了すると、そのセッションから起動
  されたすべてのプログラムに送られる。</li>
<li><code>SIGINT</code> 信号は使用者が現在定義されている割り込み文字 (<code>C-c</code>) を入力すると、現
  在キーボードに接続されているすべてのプロセスに送られます。</li>
</ul>
<p>信号はプロセス間通信の状況によっては役に立つこともある。POSIX 標準の信号集合にはこの用途を目的とした信号 <code>SIGUSR1</code> と <code>SIGUSR2</code> が含まれている：</p>
<p>They are often employed as a control channel for <em>daemons</em> (programs that run
constantly, invisibly, in background), a way for an operator or another program
to tell a daemon that it needs to either reinitialize itself, wake up to do
work, or write internal-state/debugging information to a known location.</p>
<p>信号プロセス間通信でよく使われる技法は、いわゆる pid ファイルだ。プロセス ID を含む小さなファイルを指す。</p>
<ul>
<li>信号が必要なプログラムは pid ファイルを既知の場所に書き込む。</li>
<li>他のプログラムはその pid ファイルを読んでプロセス ID を知る。</li>
<li>ロックファイルの役目を果たすこともある。</li>
</ul>
<p>信号を N 個受信しても N 回処理するとは限らない。</p>
<blockquote>
<p>Depending on what variant of signals semantics the system supports, the second
and later instances may be ignored, may cause an unexpected process kill, or
may have their delivery delayed until earlier instances have been processed
(on modern Unixes the last is most likely).</p>
</blockquote>
<p>脚注に競合状態の定義が述べられている：</p>
<blockquote>
<p>A ‘race condition’ is a class of problem in which correct behavior of the
system relies on two independent events happening in the right order, but
there is no mechanism for ensuring that they actually will. Race conditions
produce intermittent, timing-dependent problems that can be devilishly
difficult to debug.</p>
</blockquote>
<!-- intermittent: not happening regularly or continuously -->

<h4 id="system-daemons-and-conventional-signals">System Daemons and Conventional Signals<a class="headerlink" href="#system-daemons-and-conventional-signals" title="Permanent link">&para;</a></h4>
<p><code>SIGHUP</code> と <code>SIGTERM</code> について述べられている。</p>
<p><code>SIGHUP</code> はもともとは、モデム接続を切断したときに発生するような、シリアル回線降下時にプログラムに送信される信号だった。</p>
<p>次のシステムデーモンは再初期化（つまり rc ファイルを更新して再起動したい）の信号として <code>SIGHUP</code> を受け付ける：</p>
<ul>
<li>bootpd(8)</li>
<li>gated(8)</li>
<li>inetd(8)</li>
<li>mountd(8)</li>
<li>named(8)</li>
<li>nfsd(8)</li>
<li>ypbind(8)</li>
</ul>
<p><code>SIGTERM</code> は <code>SIGKILL</code> とは異なりていねいに停止する。一時ファイルのクリーンアップ、データベースへの最終更新のフラッシュなどを含むことが多い。</p>
<blockquote>
<p>When writing daemons, follow the Rule of Least Surprise:</p>
</blockquote>
<p>これらの規約を使用し、手引書を読んで既存の手本を探すことだ。</p>
<h4 id="case-study-fetchmails-use-of-signals">Case Study: <code>fetchmail</code>'s Use of Signals<a class="headerlink" href="#case-study-fetchmails-use-of-signals" title="Permanent link">&para;</a></h4>
<p><code>fetchmail</code> をデーモンモードで走らせるときの挙動：</p>
<ul>
<li>構成ファイルで定義されたすべてのリモートサイトからメールを定期的に収集する</li>
<li>ユーザーの介入なしにポート 25 のローカル SMTP リスナーにメールを渡す</li>
<li>収集の試行と試行の間に使用者定義の間隔で sleep する</li>
</ul>
<p>引数なしで <code>fetchmail</code> を起動するとデーモンがすでに起動中かどうかを調べる。</p>
<ul>
<li>No: 構成ファイルに従いながら上記のごとく起動する。</li>
<li>Yes: 新しい <code>fetchmail</code> プロセスは古いそれに信号を送る。デーモンプロセスはすぐ
  に覚醒してメールを収集し、新しいプロセスは停止する。</li>
</ul>
<h4 id="sockets">Sockets<a class="headerlink" href="#sockets" title="Permanent link">&para;</a></h4>
<div class="admonition note todo">
<p class="admonition-title">Note</p>
<p>ソケットプログラミングを全然知らないので内容が頭に入らない。出直してくる。</p>
</div>
<p>ソケットを介して通信するプログラム同士は通常、双方向のバイトストリームを見ることになる。このバイトストリームの性質はこう：</p>
<ul>
<li>直列化されている（バイト列は送信されたその順番に受信される）</li>
<li>信頼性が高い</li>
<li>ソケットディスクリプターは一度取得すると、基本的にファイルのそれのように動作す
  る</li>
</ul>
<p>次の警句はローカルマシンで閉じた I/O と、リモートマシンとの I/O との違いをわかりやすく表現している：</p>
<blockquote>
<p>Local I/O is ‘yes/no’. Socket I/O is ‘yes/no/maybe’. And nothing can ensure
delivery — the remote machine might have been destroyed by a comet. (Ken
Arnold)</p>
</blockquote>
<p>次の段落は何を述べているのか全くわからない。私の学習不足だ：</p>
<blockquote>
<p>At the time a socket is created, you specify a protocol family which tells the
network layer how the name of the socket is interpreted. ...</p>
</blockquote>
<p>双方向プロセス間通信にはソケットを使うのが通常は正しい：</p>
<blockquote>
<p>All modern Unixes support BSD-style sockets, and as a matter of design they
are usually the right thing to use for bidirectional IPC no matter where your
cooperating processes are located.</p>
</blockquote>
<p>現代では、分散運用のためにコードを scale up する必要があることを想定しておくのがよい。</p>
<blockquote>
<p>The separation of address spaces that sockets enforce is a feature, not a bug.</p>
</blockquote>
<p>ソケットをそつなく使うには、ソケット間で使うアプリケーションプロトコルを設計することから始めろ。アプリケーションプロトコル設計の議論については<a href="textuality.html">第五章</a>を見ろ。</p>
<h5 id="case-study-postgresql">Case Study: PostgreSQL<a class="headerlink" href="#case-study-postgresql" title="Permanent link">&para;</a></h5>
<p>PostgreSQL の編成：</p>
<ul>
<li>サーバー (<code>postmaster</code>)<ul>
<li>データベースファイルへ排他的にアクセスすることが可能。</li>
<li>マシン一台につきサーバープロセス一つが裏で稼働する。</li>
<li>TCP/IP ソケットを通して SQL で要求を聞く。テキスト形式で応答する。</li>
<li>複数クライアントを同時に扱うことが可能。互いの要求を干渉しないように要求を
  直列化する。</li>
</ul>
</li>
<li>クライアントが少なくとも三つ<ul>
<li>サーバーへのセッションを開始する</li>
<li>サーバーと SQL 交信を行う</li>
<li>データベースがどのように保存されているかは知らない</li>
<li>それぞれが異なる UI を備えることも可能。</li>
</ul>
</li>
</ul>
<p>このような構成は Unix データベースではごく一般的なもので、SQL クライアントとサーバーを混在させることがしばしば可能なほどだ。</p>
<h5 id="case-study-freeciv">Case Study: Freeciv<a class="headerlink" href="#case-study-freeciv" title="Permanent link">&para;</a></h5>
<p>[Freeciv] については<a href="transparency.html">前章</a>で。</p>
<blockquote>
<p>But more critical to the way it supports multiplayer gaming is the
client/server partitioning of the code.</p>
</blockquote>
<p>オンラインゲームであるので、アプリケーションがネットワークのあちらこちらに分散しているという前提に注意。</p>
<ul>
<li>実行中のゲームの状態はゲームエンジンであるサーバープロセスが維持する。ゲームロ
  ジックはすべてサーバーが処理する。</li>
<li>実行中のプレイヤーは GUI クライアントを実行し、パケットプロトコルを通じて情報
  やコマンドをサーバーを相手に交換する。GUI の詳細はクライアントが処理する。クラ
  イアントによって異なるインターフェースが与えられている。</li>
</ul>
<p>これは多人数参加型オンラインゲームの典型的な構成だ。</p>
<p>ソケット通信規約の使い分けに関するコメント。この本は 2003 年に執筆されたが、現代でもこのように実装されるはずだ：</p>
<blockquote>
<p>The packet protocol uses TCP/IP as a transport, so one server can handle
clients running on different Internet hosts. Other games that are more like
real-time simulations (notably first-person shooters) use raw Internet
datagram protocol (UDP) and trade lower latency for some uncertainty about
whether any given packet will be delivered.</p>
</blockquote>
<!-- lag: the act of slowing down or falling behind -->

<h4 id="shared-memory">Shared Memory<a class="headerlink" href="#shared-memory" title="Permanent link">&para;</a></h4>
<p>通信を行うプロセスが同じ物理メモリーにアクセスできるのであれば、共有メモリーはそれらのプロセス間で情報を受け渡す最速の方法となる。</p>
<blockquote>
<p>Shared memory may be disguised under different APIs, but on modern Unixes the
implementation normally depends on the use of mmap(2) to map files into memory
that can be shared between processes.</p>
</blockquote>
<p>Python でも名前が <code>mmap</code> というモジュールを使う。</p>
<p>共有メモリーを利用するプログラムは、通常、共有部にある手旗信号変数を使用して競合と膠着の問題を自分で処理しなければならない。マルチスレッディングでの問題に似ているが、«more manageable because default is <em>not</em> to share memory» であり、より御しやすい。</p>
<p>共有メモリーの応用例：</p>
<ul>
<li>Apache Web サーバー得点表機能：主プロセスと Apache 像の負荷共有プール間の通信。</li>
<li>X の実装：クライアントとサーバーが同じマシンに常駐している場合。ソケット通信の
  オーバーヘッドを避けるために、ライアントとサーバー間で巨大な画像を受け渡す。</li>
</ul>
<blockquote>
<p>The mmap(2) call is supported under all modern Unixes, including Linux and the
open-source BSD versions; this is described in the Single Unix Specification.
It will not normally be available under Windows, MacOS classic, and other
operating systems.</p>
</blockquote>
<p>本書出版時とは異なる可能性アリ。あるいは同名の機能があるが似て非なるものである可能性アリ。</p>
<p>Unix のプロセス間通信は二通りに進化した：</p>
<blockquote>
<p>The BSD direction led to sockets. The AT&amp;T lineage, on the other hand,
developed named pipes (as previously discussed) and an IPC facility,
specifically designed for passing binary data and based on shared-memory
bidirectional message queues.</p>
</blockquote>
<p>名前付きパイプはソケットに取って代わられたのだった。</p>
<p>低水準：</p>
<blockquote>
<p>The lower layer, which consists of shared memory and semaphores, still has
significant applications under circumstances in which one needs to do
mutual-exclusion locking and some global data sharing among processes running
on the same machine.</p>
</blockquote>
<p>共有メモリーと手旗信号機能 (shmget(2), semget(2), etc.) を使うことでネットワーク通信核心部を介したデータコピーの経常的負担を避けることができる。</p>
<h2 id="problems-and-methods-to-avoid">Problems and Methods to Avoid<a class="headerlink" href="#problems-and-methods-to-avoid" title="Permanent link">&para;</a></h2>
<p>TCP/IP を介した BSD 流ソケットが Unix のプロセス間通信手法の主流だ。</p>
<p>時代遅れの手法の中にはまだ完全に死滅していないものもあり、他の OS から実用性に疑問のある手法が輸入されている。</p>
<h3 id="obsolescent-unix-ipc-methods">Obsolescent Unix IPC Methods<a class="headerlink" href="#obsolescent-unix-ipc-methods" title="Permanent link">&para;</a></h3>
<p>Unix の歴史は時代遅れのプロセス間通信とネットワークモデルに結びついた API の死骸にまみれている。</p>
<ul>
<li>最終的には BSD ソケットが勝利し、プロセス間通信はネットワークに統合された。</li>
<li>Unix の文書には歴史的遺物がまだ使われているかのような誤解を与えるような言及が
  ある可能性が高いので、知っておくと便利だ。</li>
</ul>
<blockquote>
<p>The real explanation for all the dead IPC facilities in old AT&amp;T Unixes was
politics. The Unix Support Group was headed by a low-level manager, while some
projects that used Unix were headed by vice presidents. They had ways to make
irresistible requests, and would not brook the objection that most IPC
mechanisms are interchangeable. -- Doug McIlroy</p>
</blockquote>
<p>死因の真相が政治ならば、設計や性能は死ぬほどのものではなかったと解釈できる？</p>
<h4 id="system-v-ipc">System V IPC<a class="headerlink" href="#system-v-ipc" title="Permanent link">&para;</a></h4>
<p>System V プロセス間通信機能は先述の共有メモリー機能を基にしたメッセージ送受機能だ。</p>
<p>System V プロセス間通信機能は Linux や他の現代的な Unix にもある。遺物につき使われることはあまりない。</p>
<h4 id="streams">Streams<a class="headerlink" href="#streams" title="Permanent link">&para;</a></h4>
<p>大文字の方を中心に読むしかない。</p>
<p>Dennis Ritchie が考案したネットワーキング実装の再実装版 STREAMS に関する記述をこのノートでは拾っていく。</p>
<ul>
<li>STREAMS は System V 3.0 (1986) で初めて利用可能になった。</li>
<li>STREAMS 機能はユーザープロセスとカーネル内の指定されたデバイスドライバーとの間
  の全二重インターフェイス（鉄道の複線を連想するといい？）を搭載していた。</li>
</ul>
<blockquote>
<p>The device driver might be hardware such as a serial or network card, or it
might be a software-only pseudodevice set up to pass data between user
processes.</p>
</blockquote>
<p>興味深い特徴（私にはチンプンカンプン）：</p>
<blockquote>
<p>it is possible to push protocol-translation modules into the kernel's
processing path, so that the device the user process ‘sees’ through the
full-duplex channel is actually filtered.</p>
</blockquote>
<p>この機能は、例えば、端末デバイス用の行編集規約を実装するために使用できる。あるいは、IP や TCP のような規約をカーネルに直接配線せずに実装することもできる。</p>
<p>元々の Streams はとある厄介な機能を一掃する試みとして生まれたが、時代が進んでその厄介事を生む環境が姿を消していくにつれ、STREAMS が有する柔軟性も有用性を失っていったというようなことを述べている。</p>
<p>Linux をはじめとするオープンソースの Unix は STREAMS を事実上破棄 (have
effectively discarded) している。</p>
<h3 id="remote-procedure-calls">Remote Procedure Calls<a class="headerlink" href="#remote-procedure-calls" title="Permanent link">&para;</a></h3>
<p>遠隔手続き呼出しをインポートする企てがほとんど失敗する理由を考察している。</p>
<p>第一は遠隔手続き呼出しインターフェイスが容易に発見可能でないことだ：</p>
<blockquote>
<p>that is, it is difficult to query these interfaces for their capabilities, and
difficult to monitor them in action without building single-use tools as
complex as the programs being monitored</p>
</blockquote>
<p><a href="transparency.html">第六章</a>で原因を検討したのだった。</p>
<p>関連する問題として、より豊富な型シグネチャーを持つインターフェイスはより複雑に、したがってより脆くなる傾向がある。次の文章に続くのだが、難し過ぎて意味が汲めない：</p>
<!-- brittle: delicate and easily broken -->

<blockquote>
<p>Over time, they tend to succumb to ontology creep as the inventory of types
that get passed across interfaces grows steadily larger and the individual
types more elaborate. Ontology creep is a problem because structs are more
likely to mismatch than strings; if the ontologies of the programs on each
side don't exactly match, it can be very hard to teach them to communicate at
all, and fiendishly difficult to resolve bugs. The most successful RPC
applications, such as the Network File System, are those in which the
application domain naturally has only a few simple data types.</p>
</blockquote>
<p>NFS のような最も成功した RPC アプリケーションはアプリケーションドメインが元からわずかな単純データ型しか持たないものだ。</p>
<p>古典的な RPC では、物事を単純に保つのではなく、複雑で漠然とした方法で行うのは簡単過ぎる。</p>
<ul>
<li>Windows COM と DCOM はいかに悪い方向に向かうかを示す典型的</li>
<li>Apple は OpenDocを放棄した</li>
<li>CORBA も Java RMI も、Unix の世界では姿を消していった</li>
</ul>
<blockquote>
<p>Andrew S. Tanenbaum and Robbert van Renesse have given us a detailed analysis
of the general problem in <em>A Critique of the Remote Procedure Call Paradigm</em>,
a paper which should serve as a strong cautionary note to anyone considering
an architecture based on RPC.</p>
</blockquote>
<p>Unix の伝統は透明で発見可能なインターフェイスを強く好む。これは、Unix 文化がテキスト通信規約によるプロセス間通信に執着し続けている背景の一つだ。</p>
<blockquote>
<p>It is often argued that the parsing overhead of textual protocols is a
performance problem relative to binary RPCs</p>
</blockquote>
<p>これに対し、次の二点からバイナリー RPC のほうが遅延問題悪化傾向がはるかにあると述べる：</p>
<ul>
<li>RPC インターフェイスは、ある呼び出しがどれだけのデータのシリアライズを伴うかを
  容易に予測できない</li>
<li>RPC モデルはプログラマーがネットワーク交信を経費無料として扱うことを奨励する傾
  向がある</li>
</ul>
<p>仮にテキストストリームが RPC より効率が劣ったとしても、次で取り戻せる：</p>
<ul>
<li>開発時間を増やしたり、構造を複雑にしたりするよりも、ハードウェアを増強すること
  で対処可能。</li>
<li>より単純、モデル化しやすい、理解しやすいシステムを設計する能力がある。</li>
</ul>
<p>今日、RPCとUnixのテキストストリームへの愛着は、XML-RPCやSOAPのようなプロトコルによって、興味深い形で収束しつつある。 これらのプロトコルは、テキストで透過的であるため、Unixプログラマーにとっては、醜くて重いバイナリー・シリアライゼーション・フォーマットよりも使いやすい。 Tanenbaumとvan Renesseが指摘したような一般的な問題をすべて解決するわけではないが、テキストストリームとRPCの両方の長所を兼ね備えている。</p>
<blockquote>
<p>Today, RPC and the Unix attachment to text streams are converging in an
interesting way, through protocols like XML-RPC and SOAP. （中略） they do in
some ways combine the advantages of both text-stream and RPC worlds.</p>
</blockquote>
<h3 id="threads-threat-or-menace">Threads — Threat or Menace?<a class="headerlink" href="#threads-threat-or-menace" title="Permanent link">&para;</a></h3>
<p>Unix の開発者にはスレッド（アドレス空間全体を共有するプロセス）を使用する伝統はない。スレッドは最近他から輸入されたものだという。</p>
<p>Unix はプロセス起動が安く付くので、独自のアドレス空間を持つ軽量プロセスに対してスレッドの代用品には適切でない。</p>
<blockquote>
<p>the idea of threads is native to operating systems with expensive
process-spawning and weak IPC facilities.</p>
</blockquote>
<p>定義上、通常プロセスの娘（原文）スレッドは皆同じ大域的記憶域を共有する。</p>
<blockquote>
<p>The task of managing contentions and critical regions in this shared address
space is quite difficult and a fertile source of global complexity and bugs.</p>
</blockquote>
<!-- fertile: fertile land or soil is able to produce -->

<p>スレッドは、互いの内部状態を知り過ぎてしまうため、バグの発生源となりやすい。プロセス間通信ならばアドレス空間が自動的にカプセル化しているが、そういうものがない。それゆえ、スレッド化されたプログラムは、通常の競合問題だけでなく、タイミングに依存する全く新しい区分のバグに悩まされる。</p>
<p>TLS という記憶域が発明された。</p>
<blockquote>
<p>Threads often prevent abstraction. In order to prevent deadlock, you often
need to know how and if the library you are using uses threads in order to
avoid deadlock problems. Similarly, the use of threads in a library could be
affected by the use of threads at the application layer. -- David Korn</p>
</blockquote>
<p>まだある。スレッド化には従来のプロセス分離に対する利点を損なう性能代価がある。スレッド化によってプロセスコンテキストを高速に切り替える経常費用をある程度取り除くことはできるが、スレッド同士が互いに踏み合わないように共有データ構造をロックすることは同じくらい代償が付く。</p>
<p>この問題は根本的であり、対称型マルチプロセッシングのための Unix カーネルの設計においても継続的な問題であった：</p>
<blockquote>
<p>As your resource-locking gets finer-grained, latency due to locking overhead
can increase fast enough to swamp the gains from locking less core memory.</p>
</blockquote>
<p>読書案内：</p>
<blockquote>
<p>For more discussion and a lucid contrast with event-driven programming, see
<em>Why Threads Are a Bad Idea</em>.</p>
</blockquote>
<h2 id="process-partitioning-at-the-design-level">Process Partitioning at the Design Level<a class="headerlink" href="#process-partitioning-at-the-design-level" title="Permanent link">&para;</a></h2>
<p>関連技法一覧：</p>
<ul>
<li>一時ファイル</li>
<li>主従プロセス関係</li>
<li>ソケット</li>
<li>遠隔手続き呼出し</li>
<li>それ以外の双方向プロセス間通信</li>
</ul>
<p>上記の技法はある水準では等価だ。違いは次の縁にある。</p>
<ul>
<li>プログラムがどのように通信を確立するか</li>
<li>いつどこでメッセージの表現形式変換を行うか</li>
<li>どのような種類の一時保存問題が発生するか</li>
<li>どの程度までメッセージの不可分性を保証するか</li>
</ul>
<p>PostgreSQL のクライアントとサーバーはソケットを介して通信する。他の双方向プロセス間通信方式を仕様しても設計の型はほとんど同じだろう。</p>
<p>サーバーとクライアントに分割して双方向通信をするという設計はアプリケーションの複数の実体が、すべての実体間で共有される資源へのアクセスを管理する必要がある状況で特に効果的だ。次のどちらでもいい：</p>
<ul>
<li>単一のサーバープロセスが資源の競合を管理する</li>
<li>協力し合う同格の実体それぞれが死活的な資源を管理する</li>
</ul>
<p>この分割設計は命令サイクルを大量に消費するアプリケーションを複数のサーバーに分散させるのにも役立つ。インターネットを介した分散計算に適していることがある。</p>
<p>これらの peer-to-peer プロセス間通信技術はすべて似ている。評価判断は主に次だ：</p>
<ul>
<li>プログラム複雑度の経常費用</li>
<li>設計にもたらす不透明性の程度</li>
</ul>
<blockquote>
<p>This, ultimately, is why BSD sockets have won over other Unix IPC methods, and
why RPC has generally failed to get much traction.</p>
</blockquote>
<p>スレッドは根本的に異なる。異なるプログラム間の通信ではなく、単一プログラムのプロセス内での時分割方式のようなものだ。</p>
<blockquote>
<p>threading is strictly a performance hack. It has all the problems normally
associated with performance hacks, and a few special ones of its own.</p>
<p>Accordingly, while we should seek ways to break up large programs into simpler
cooperating processes, the use of threads within processes should be a last
resort rather than a first.</p>
</blockquote>
<p>スレッドよりプロセスと憶えておこう。</p>
<blockquote>
<p>If you can use limited shared memory and semaphores, asynchronous I/O using
SIGIO, or poll(2)/select(2) rather than threading, do it that way. Keep it
simple;</p>
</blockquote>
<p>次の三つの組み合わせは特に危険であるという：</p>
<ul>
<li>スレッド</li>
<li>遠隔手続き呼び出しインターフェース</li>
<li>重量級のオブジェクト指向設計</li>
</ul>
<p>この手のプロジェクトに巻き込まれたら逃げ出してもいいとまで述べている。</p>
<p>実世界でのプログラミングは複雑性をどうにかするのがそのすべてだ。</p>
<blockquote>
<p>Tools to manage complexity are good things. But when the effect of those tools
is to proliferate complexity rather than to control it, we would be better off
throwing them away and starting from zero.</p>
</blockquote></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>© 2025 プレハブ小屋 All rights reserved.</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
