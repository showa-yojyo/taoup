# Chapter 14. Languages

> To C or Not To C?

『ハムレット』のパロデー。

[TOC]

## Unix's Cornucopia of Languages

Cornucopia を辞書で引くと «a symbol of plenty consisting of a goat's horn
overflowing with flowers, fruit, and corn» (OED) とある。豊穣の象徴？

Unix は計算機の歴史における他のどの OS よりも多くの異なる言語の寄主である可能性
がある。その多様性の理由は二つはある：

* Unix が研究や教育の基礎として広く使われている。
* アプリケーションの設計と適切な実装言語を釣り合わすことで、生産性が大きく変わる
  という事実。

Unix の伝統は応用領域固有言語や、現在一般的にスクリプト言語と呼ばれているものの
設計を奨励している。

スクリプト言語という術語は少々扱いにくい。そう呼ばれている言語はその呼び名の枠を
超えた能力を持つまでに成長しており、独立した汎用プログラミング言語になっている。

これらすべてを「スクリプト言語」で一緒くたにできる理由の一つは、これらの言語がほ
とんど同じ発達をしているからだ：

* インタープリターを持つことで、動的ストレージ管理の自動化も比較的容易になる。
* 動的なストレージ管理を自動化するには、値のコピーや生のポインターを渡すのではな
  く、参照を使う必要がある。
* 参照を使うことで、実行時多態性とオブジェクト指向は次の段階に簡単に進むことがで
  きる。

Unix 哲学を効果的に応用するにはプログラマー個人の言語操作能力の集合に C 以上のも
のが含まれている必要がある。

アプリケーション言語の選択は典型的な信仰の問題だ。

> People get very attached to these tools and will sometimes defend them past
> all reason.

## Why Not C?

C 言語は Unix の第一言語だ。

1980 年代初頭から C 言語は計算機業界のほとんどの場所でシステムプログラミングを支
配するようになった。C とその子孫である C++ は本書執筆時 2003 年時点でアプリケー
ションプログラミングをほぼ完全に支配している。例外は：

* 科学技術計算における Fortran
* 銀行や保険会社における COBOL 金融アプリケーション

C/C++ は新しいアプリケーションの開発を始めるのに、今日ではほとんど常に誤った手段
であると著者は断言する。

C/C++ は実装とデバッグにかかる時間の増加を犠牲にして効率を最適化している。システ
ムプログラムや時間的に重要なアプリケーションのカーネルを書くことは今でも理にか
なっているが、演算装置は千倍速くなり、記憶容量は千倍大きくなり、記憶装置は万倍大
きくなっている。

こうしたコストの急落は、プログラミングの経済性を根本的に変えてしまう。たいていの
状況では C 言語が許す限りマシンの資源を節約しようとしても、もはや意味がない。

代わりに、経済的に最適な選択とは次だ：

* デバッグ時間を最小化し、
* 人間によるコードの長期的な保守性を最大化する

したがって、ほとんどの種類の実装（試作を含む）は新世代インタプリター型言語やスク
リプト言語の方が適している。

C/C++ の中心的な問題はプログラマーに独自のメモリー管理を要求することにある：

* 変数の宣言
* ポインター連鎖リストの明示的な管理
* バッファーの拡張
* バッファーオーバーランの検出と防止
* 動的ストレージの割り当てと解放

この仕事の一部はガベージコレクターを C 言語に後付けすることで自動化することがで
きる。しかし C 言語の設計上、これが完全な解決策になることはあり得ない。

メモリー管理は複雑化とエラーの莫大な原因だ。

[124]。バッファ・オーバーランは、クラッシュやセキュリティ・ホールの一
般的な原因である。 動的メモリ管理は、メモリ・リークやステール・ポインタの問題の
ような、陰湿で追跡が困難なバグを生み出すことで特に悪名高い。

* 複雑なデータ構造を操作するプログラムでは、開発時間の三、四割がストレージ管理に
  費やされていると推定する研究 (Hans Boehm. *Advantages and Disadvantages of
  Conservative Garbage Collection*) がある。
* （確かな数字があるわけではないが）経験豊富なプログラマーの多くは、メモリー管理
  のバグが実世界のコードにおける永続的なエラーの唯一最大の原因であると考えている。

今日の状況下では、メモリー管理を自動化する実装言語（少し多めのサイクルとコアを使
用する代償としてバグが一桁減る）の方がはるかに理にかなっている。

実世界のプログラムは演算装置そのものの使用効率よりも、I/O イベントの待ち時間、
ネットワークの待ち時間、キャッシュラインのフィルによって制限される傾向がある。

Unix 界では特に 1990 年前後からこのような考え方に徐々に近づいている。多くの Unix
プログラマーは Perl や Python が教えてきたことをまだ吸収している。

Unix 界以外でも同じ傾向がよりゆっくりと起きている。例えば：

* Microsoft Windows や NT のアプリケーション開発で見られる C++ から Visual Basic
  への継続的な移り変わり
* メインフレームの世界における Java への移行

C/C++ に対する反論は他の（メモリー管理をプログラマーに任せるという基本的な設計
の）従来型コンパイル言語にも同じように当てはまる。従来の言語間の違いは表面的なも
のにとどまる。

## Interpreted Languages and Mixed Strategies

手作業によるメモリー管理を回避する言語では、実行ファイルのどこかにメモリーマネ
ジャーを内蔵している。このような言語の実行時動作環境はプログラム部分（スクリプト
そのもの）とインタープリター部分に分かれており、インタープリターが動的ストレージ
を管理している。

Unix を含む最新の OS では、インタープリターの核心を複数のプログラム部分で共有
し、それぞれの実際の間接費を減らすことが可能だ。

1970 年代半ば、Unix シェルは完全なインタプリター型プログラミング言語として設計さ
れていた。その当時でも、シェルだけでプログラムを書いたり、定型の実用品や C 言語
の自作プログラムをつなぎ合わせて、部分の総和以上のものを作るための接着ロジックを
書くためにシェルを使うことはよくあった。

> Advanced shell programming mixes languages freely, employing both binaries and
> interpreted elements from half a dozen or more other languages for subtasks.

上の記述の要点はバイナリーとスクリプトの分量に言及していることだと思う。

それぞれの言語が得意とすることを行い、各部品は他のものと狭いインターフェイスを持
つモジュールであり、汎用言語で単一の怪物一枚岩としてコードされた場合よりも全体の
大域的複雑度がはるかに低くなる。

## Language Evaluations

言語を混在させることはプログラミングの知識集約型様式だ。これをうまくやるには次の
両方が必要となる：

* 適切な種類の言語に関する実用的な知識
* それらの言語の得意分野や組み合わせ方に関する専門知識

### C

C 言語に適しているプログラムの性質：

* 最高速度が要求される
* 同時性が要求される
* OS カーネルと緊密に結合している

小さなアプリケーションの残りの部分を C で書くことが正当化されるほど効力が大きい
場合もある。

現代の条件下では C を高水準アセンブラーと考えるのがおそらく最善だろう。C の標準
規格は、標準 I/O ライブラリーなど、Unix 仮想機の機能の多くを他の OS に輸出してき
た。OS を持たないものに可能な限り近づけたいが、ポータブルであり続けたい場合に C
言語が使われる。

C 言語を学ぶべき理由のひとつは、ハードウェアアーキテクチャー水準での考え方を学ぶ
のに役立つからだ。すでにプログラマーである人々にとって、C 言語の最高の参考書であ
りチュートリアルであるのは、やはり *The C Programming Language* だ。

Unix の亜種間での C コードの移植はほとんどの場合可能であり、たいていは簡単だが、
特定の亜種（シグナルやプロセス制御など）を正しく移植するのは難しい ([Chapter
17])。

高品質 C コンパイラーがインターネット上のオープンソースソフトウェアとして入手で
きる。

> the best-known and most widely used is the Free Software Foundation's GNU C
> compiler (part of GCC, the GNU Compiler Collection), which has become the
> native C of all open-source Unix systems and many even in the closed-source
> world.

移植版は Microsoft の OS でさえ利用可能だ。[FSF のサイト](https://gcc.gnu.org/)
で入手可能だ。

C の長所は資源効率と機械との距離の近さ。短所はプログラミングが資源管理地獄である
ことだ。

#### C Case Study: `fetchmail`

### C++

#### C++ Case Study: The Qt Toolkit

### Shell

#### Case Study: `xmlto`

#### Case Study: Sorcery Linux

### Perl

#### A Small Perl Case Study: `blq`

#### A Large Perl Case Study: `keeper`

### Tcl

#### Case Study: `TkMan`

#### Moodss: A Large Tcl Case Study

### Python

#### A Small Python Case Study: `imgsizer`

#### A Medium-Sized Python Case Study: `fetchmailconf`

#### A Large Python Case Study: PIL

### Java

#### Case Study: FreeNet

### Emacs Lisp

## Trends for the Future

## Choosing an X Toolkit

[Chapter 17]: <../community/portability.md>
